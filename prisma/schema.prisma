// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id               String    @id @default(cuid()) @map("_id")
  name             String
  email            String    @unique
  emailVerified    Boolean   @default(false)
  image            String?
  role             String?   @default("USER")
  phone            String?
  phoneVerified    Boolean   @default(false)
  profileCompleted Boolean   @default(false)
  subscriptionId   String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  accounts Account[]
  sessions Session[]

  // Relations for Creator-Editor map
  creatorMaps CreatorEditorMap[] @relation("CreatorRelation")
  editorMaps  CreatorEditorMap[] @relation("EditorRelation")

  // Relations for contributions
  editorContributions Contribute[]     @relation("EditorRelation")
  authorComments      VersionComment[] @relation("AuthorRelation")

  // Relation for YouTube creator
  ytCreator YtCreator?

  // Relation for account editor maps
  editorAccountMaps AccountEditorMap[] @relation("EditorAccountRelation")

  @@map("user")
}

model Account {
  id                    String    @id @default(cuid()) @map("_id")
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([accountId, providerId])
  @@map("account")
  @@index([userId])
}

model Session {
  id        String   @id @default(cuid()) @map("_id")
  expiresAt DateTime
  token     String   @unique
  userId    String
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
  @@index([userId])
}

model Verification {
  id         String   @id @default(cuid()) @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// Media model for Drive uploads

model Media {
  id             String   @id @default(cuid()) @map("_id")
  type           String // VIDEO, IMAGE, etc.
  integrationUrl String?
  integrationKey String? // Drive file ID
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  videoContributions            Contribute[]          @relation("VideoRelation")
  thumbnailContributions        Contribute[]          @relation("ThumbnailRelation")
  contributionVersions          ContributionVersion[] @relation("VersionVideoRelation")
  contributionVersionThumbnails ContributionVersion[] @relation("VersionThumbnailRelation")
  folderItems                   FolderItem[]

  @@map("media")
}

// Folder model

model Folder {
  id        String    @id @default(cuid()) @map("_id")
  folderId  String // Drive folder ID
  name      String
  creatorId String
  editorId  String
  accountId String
  deletedAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  items FolderItem[]

  @@map("folder")
}

// Folder item for many-to-many relation between Folder and Media

model FolderItem {
  id        String    @id @default(cuid()) @map("_id")
  folderId  String
  mediaId   String
  deletedAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  folder Folder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  media  Media  @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@unique([folderId, mediaId])
  @@map("folder_item")
}

// Contribution model

model Contribute {
  id          String   @id @default(cuid()) @map("_id")
  accountId   String
  editorId    String
  videoId     String
  thumbnailId String
  title       String
  description String?
  tags        String[]
  duration    Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  account   YtCreator             @relation(fields: [accountId], references: [id])
  editor    User                  @relation("EditorRelation", fields: [editorId], references: [id])
  video     Media                 @relation("VideoRelation", fields: [videoId], references: [id])
  thumbnail Media                 @relation("ThumbnailRelation", fields: [thumbnailId], references: [id])
  versions  ContributionVersion[]

  @@map("contribute")
}

// Contribution version model

model ContributionVersion {
  id           String   @id @default(cuid()) @map("_id")
  contributeId String
  videoId      String
  thumbnailId  String
  title        String
  description  String?
  tags         String[]
  duration     Int?
  status       String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  contribute Contribute       @relation(fields: [contributeId], references: [id], onDelete: Cascade)
  video      Media            @relation("VersionVideoRelation", fields: [videoId], references: [id])
  thumbnail  Media            @relation("VersionThumbnailRelation", fields: [thumbnailId], references: [id])
  comments   VersionComment[]

  @@map("contribution_version")
}

// Version comment model

model VersionComment {
  id        String   @id @default(cuid()) @map("_id")
  versionId String
  authorId  String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  version ContributionVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)
  author  User                @relation("AuthorRelation", fields: [authorId], references: [id])

  @@map("version_comment")
}

// Creator-Editor Map

model CreatorEditorMap {
  id        String   @id @default(cuid()) @map("_id")
  creatorId String
  editorId  String
  status    String   @default("PENDING") // PENDING, ACTIVE, INACTIVE
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator User @relation("CreatorRelation", fields: [creatorId], references: [id], onDelete: Cascade)
  editor  User @relation("EditorRelation", fields: [editorId], references: [id], onDelete: Cascade)

  @@unique([creatorId, editorId])
  @@map("creator_editor_map")
}

// Account-Editor Map

model AccountEditorMap {
  id        String   @id @default(cuid()) @map("_id")
  accountId String
  editorId  String
  status    String   @default("ACTIVE") // ACTIVE, INACTIVE
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account YtCreator @relation(fields: [accountId], references: [id], onDelete: Cascade)
  editor  User      @relation("EditorAccountRelation", fields: [editorId], references: [id], onDelete: Cascade)

  @@unique([accountId, editorId])
  @@map("account_editor_map")
}

// YouTube Creator model

model YtCreator {
  id           String   @id @default(cuid()) @map("_id")
  creatorId    String   @unique
  email        String
  accessToken  String
  refreshToken String
  status       String   @default("ACTIVE")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  creator       User               @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  accounts      AccountEditorMap[]
  contributions Contribute[]

  @@map("yt_creator")
}
